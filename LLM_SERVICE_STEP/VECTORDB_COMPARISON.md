## 왜 벡터 DB를 사용하는가  

### 현재 서비스에서의 벡터 DB가 필요한 이유  
  
1. **sentiment**   
    대표 벡터 TOP-k에서 llm이 긍/부정 개수 세기.
    직접 수식 계산으로 비율 계산.
2. **summary**    
    대표 벡터 top_k를 에서 llm이 aspect,claim 추출.
    각 aspect를 대표벡터 top_k와 cos 비교해서 할루시네이션 검증,
    실패 시, 더 일반적인 문장으로 바꾸고 재시도, 검증 절차 반복.
    그 aspect들을 llm이 자연스러운 문장으로만 연결 수행.
    ( aspect 추출 )
3. **strength**  
    1. 대표 벡터 top_k에서 각 aspect,claim 추출.
    2. 각 aspect로 **벡터 검색** 수행해 근거 문장 수집(limit=50)
    근거 문장 수집의 효과
        1. 근거 문장의 개수로 할루시네이션 방지
        2. 근거 문장들을 support_count, consistency -> support_count + 근거 문장들이 일관되는지 판단.
    3. 각 aspect의 claim들을 union-find로 비슷한 건 하나로 합치기
    4. 이 각 aspect들의 claim들을 각 음식점에 **벡터 검색**을 통해
    5. 각 aspect별 강점을 뽑고 각 타겟 aspect vs 각 comp aspect 유사도 파악,
       유사하다 = 타겟의 강점 x
       유사하지 않다 = 타겟의 강점 o 
       -> (코사인 x 별도의 수식)

    -->**만약 벡터 DB를 쓰지 않았다면,**  
        각 aspect에 대한 claim을 다른 음식점에서 의미 검색을 하기가 어려움.

4. **image search**  
    1. 쿼리 작성
    2. 
        2-1 그 쿼리가 의미의 구체화가 필요할 경우 llm이 쿼리 재빌딩.
        2-2 의미의 구체화가 필요없는 쿼리의 경우 쿼리 그대로 반환.
    3. 그걸로 **벡터 검색** 수행해 이미지들 반환

    -->**만약 벡터 DB를 쓰지 않았다면,**  
        리뷰에서 의미 검색을 하기가 어려움.

---
    


| DB                     | 디스크 저장(영속성) | 디스크 기반 쿼리/인덱스 옵션              | 비고                                                                 |
| ---------------------- | ----------- | ----------------------------- | ------------------------------------------------------------------ |
| **Qdrant**             | ✔️          | ✔️ (on_disk true + mmap)      | 명시적인 디스크 모드 옵션 ([Qdrant][1])                                       |
| **Milvus**             | ✔️          | ✔️ (DiskANN 등 disk-based 인덱스) | 인덱스 선택을 통한 disk 활용 ([The New Stack][2])                            |
| **Weaviate**           | ✔️          | 🟡 (persistent + mmap)        | 디스크 저장 + mmap, 완전 디스크-전용 쿼리는 문서화 제한적 ([Weaviate Documentation][3]) |
| **Chroma / others**    | ✔️          | ❌ (메모리 전체 로딩 기반)              | 파일 저장은 가능하지만 디스크-기반 검색은 아님 ([Medium][4])                           |
| **Pinecone / Managed** | 내부 구현에 따라 다름 (사용자가 알 수 없음)    |     내부 구현에 따라 다름(사용자가 알 수 없음)                         | 내부 구현에 따라 다름, 옵션 자체가 존재하지 않음 ([Airbyte][5])                             |

---

**on-disk+mmap를 하려는 이유**
1. 서버를 따로 할당해야되는게 비용, 서버관리에 대한 부담.
2. on-disk+mmap를 사용하지 않고, 영속 저장소로 사용할 경우, 모든 벡터는 메모리에 전체 할당(inmemory는 휘발이지만, 전체 메모리에 할당하는건 동일).
3. on-disk+mmap의 경우, 필요 벡터의 경우에만 RAM에 올려서 연산을 수행. 즉, 캐시 저장소와 같은 역할을 수행한다.
4. 즉, 애플리케이션 서버와 같이 같은 서버에 띄워도 부담이 없음.
5. 그리고, 만약 애플리케이션 서버와 같은 서버에 띄웠을때, 메모리의 부담이 생긴다면, 그때 다른 서버로 분리하면 되어, 현재 리소스를 최대한 활용하는 방법이며, 비용 효율적인 방법이다.
2. 따라서, on-disk+mmap가 된다면, on-disk+mmap가 좋다고 판단.

---

**다른 벡터DB 말고 Qdrant on-disk를 하려는 이유**
1. 디스크 적재 방식이니, 디스크 용량을 따라간다는게, 관리에 편리, 대규모 데이터셋 저장에도 용이.
2. 또한, Qdrant 같은 경우는 on-disk가 MMAP 방식을 통해 대규모 데이터더라도 처리시 메모리 부담이 적음.
3. Qdrant는 on-disk on/off가 쉬움.
4. Milvus는 초대규모용 벡터DB, Milvus 자체가 초기 셋팅용은 아님. 
5. 우리 서비스가 Milvus를 쓸만큼 초대규모 사용자가 들어올일이 없음.
5. 또한, Milvus는 설정이 어려움
6. HNSW 인덱스와 벡터를 디스크(메모리맵) 기반으로 저장 가능. 
    → RAM 전체를 쓰지 않고도 대규모 벡터 저장 가능.
7. Weaviate는 on-disk+mmap가 가능하지만, HNSW를 비롯한 인덱싱 기능은 제한적.
8. Chroma / others는 디스크 저장은 되어도, 검색은 안됨. 메모리 전체 검색만 지원.
9. Pinecone / Managed는 Saas 서비스라서, 무슨 방식인지 자체를 알수도 없고, 사용자가 알 필요도 없음.(--> 사용자가 관리 방식을 고려할 필요가 없기 때문.) 방식 자체도 사용자가 통제도 불가능, 따라서 다양한 요구에 유연하게 대응하기가 어렵다. 또한, saas는 pinecone의 자체 서버에서 결과를 받아오는 방식이라, 추가 비용은 반드시 드는 형태다 
