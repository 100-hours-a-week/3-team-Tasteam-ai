# Go Watchdog 마이그레이션 전략

## 개요

본 문서는 Phase 1 단계에서 Watchdog만 Go로 마이그레이션하는 전략과 그 이유를 설명합니다.
실무적 이점과 기술적 근거를 함께 정리한 내용입니다.

---

## 1. 장기 실행 안정성 (Long-running Stability)

**특징:**
- Go의 GC(가비지 컬렉션)와 런타임 관리가 단순하고 예측 가능합니다.
- Python은 장기 실행 시 `asyncio` 루프, 스레드 누수, 메모리 누적 등의 문제가 발생할 수 있습니다.
- Watchdog는 무중단 모니터링 데몬 역할을 하므로, 프로세스 안정성이 핵심이며 Go의 런타임은 이 목적에 적합합니다.
- 시스템 수준에서 goroutine이 lightweight하며, 예외 발생 시 `panic → recover` 구조로 빠르게 안정화할 수 있습니다.

**효과:**
장기간 실행해야 하는 서비스(24/7 모니터링)에서 Python보다 Go가 더 안정적입니다.

---

## 2. 리소스 효율 (Memory / CPU)

**특징:**
- Go는 런타임 오버헤드가 작고, 기본 스레드 관리가 효율적입니다.
- Python은 GIL(Global Interpreter Lock)로 인해 I/O 병렬 처리 효율이 떨어지고, 메모리 상주량이 큽니다.
- Watchdog는 대부분 `nvidia-smi` 호출, HTTP 요청, sleep 루프로 구성되어 CPU보다 I/O 대기 중심 로직입니다.
- 이러한 구조에서 Go가 더 효율적입니다.

**리소스 사용량:**
- Go: RSS 메모리 10~15MB
- Python: 70~120MB

**효과:**
GPU가 없는 idle 상태에서도 비용 부담이 거의 없는 경량 데몬을 구성할 수 있습니다.

---

## 3. 배포 편의성 (단일 바이너리)

**특징:**
- Go는 `CGO_ENABLED=0 go build -o watchdog`로 단일 실행파일을 생성할 수 있습니다.
- 컨테이너, RunPod, Docker, Kubernetes 등 어디서든 바로 실행 가능합니다.
- Python은 venv, requirements.txt, 패키지 버전 문제 등으로 배포가 복잡합니다.
- Watchdog만 Go로 전환하면 메인 서비스(Python)는 그대로 유지하고, 감시자는 독립적으로 유지할 수 있습니다.

**효과:**
빌드 한 번으로 어디서든 실행이 가능하여 운영이 단순해집니다.

---

## 4. 독립 실행 가능 (Standalone)

**특징:**
- Go Watchdog는 외부 의존성이 거의 없습니다.
- Python처럼 런타임 의존성이 없습니다.
- 별도 프로세스로 실행되어 FastAPI 서버가 다운되어도 Watchdog는 계속 동작합니다.
- 독립성 확보로 시스템 레벨 모니터링 데몬으로 격상 가능합니다.
  (예: systemd 서비스, Docker sidecar, RunPod 내부에서 별도 컨테이너)

**효과:**
LLM 서버의 헬스 상태와 수명주기 제어를 분리함으로써 전체 아키텍처가 견고해집니다.

---

## 5. 개발 시간 대비 효과 (ROI)

**특징:**
- Watchdog 로직은 다음 3개 동작으로 구성됩니다:
  1. `nvidia-smi` 호출 → GPU 사용률 파싱
  2. 최근 요청 감지 (파일 또는 HTTP ping 등)
  3. RunPod API 호출 (Resume / Stop)
- Go에서는 이 모든 기능을 표준 라이브러리만으로 구현 가능합니다 (`os/exec`, `net/http`, `encoding/json`)
- 300~400줄 수준으로 완성 가능하며, 테스트·배포·운영이 모두 단순합니다.

**효과:**
구현 복잡도는 낮지만, 운영 안정성, 비용 절감, 확장성 효과는 큽니다.

---

## 6. 구현 복잡도

**특징:**
- GPU 상태 감시: 단순 쉘 호출
- RunPod API: 단순 REST 호출
- 타이머/쿨다운/상태 전환: 간단한 FSM(Finite State Machine)
- 복잡한 비동기 처리나 thread pool이 불필요하며, goroutine + channel로 충분합니다.

**효과:**
Go 언어의 장점을 최대한 활용하면서, Python 쪽은 그대로 유지할 수 있는 위험도가 낮은 전환 단계입니다.

---

## 요약

| 항목     | Go 전환 이점       | Python 대비          |
| ------ | -------------- | ------------------ |
| 안정성    | 장기 실행에 적합      | 메모리 누수, GIL 이슈     |
| 리소스 효율 | 10~20MB 수준     | 100MB 이상           |
| 배포     | 단일 바이너리        | 가상환경, 종속성          |
| 독립성    | FastAPI와 분리 가능 | 같은 런타임             |
| 구현 복잡도 | 낮음 (표준패키지만 사용) | asyncio, 스레드 관리 필요 |
| ROI    | 매우 높음          | 낮음                 |

---

## Go가 이 역할에 적합한 이유 (역할 특성 기준)

### 역할의 본질

Go 에이전트가 수행하는 역할은 다음과 같은 특성을 가집니다:

> 짧은 코드로, 오래 살아 있고(daemon), 외부 시스템과 많이 통신하며, 실수 없이 상태를 관리해야 하는 프로그램

이러한 특성은 Go가 설계된 목적과 일치합니다.

### 1. 장기 실행 에이전트에 최적화

**역할의 특징:**
- 24/7 실행 (메트릭 수집, 상태 모니터링)
- 메모리 누수 없이 안정적이어야 함
- 작은 VM/노드에서도 부담 없어야 함

**Go의 장점:**
- 단일 바이너리 (런타임/의존성 거의 없음)
- 메모리 footprint 작음 (10-15MB)
- 수개월 실행해도 안정적 (GC 및 런타임 관리 예측 가능)

Python도 가능하지만, 항상 실행되는 인프라 데몬에서는 Go가 더 신뢰받습니다.

### 2. 상태 전이(State Machine)를 안전하게 구현

**다루는 상태:**
```
INIT → WARMING → READY → DRAINING → TERMINATED
```

**Go의 장점:**
- `enum`(iota) 기반 상태 표현
- `switch` 문의 강제적 분기 처리
- 컴파일 타임에 오류 발견 가능 (정적 타입 언어)

잘못된 상태 전이가 치명적인 영역이므로, 정적 타입 언어가 이점이 큽니다.

### 3. 동시성 모델의 적합성

**에이전트가 동시에 수행하는 작업:**
- 주기적 메트릭 수집
- 헬스 체크 엔드포인트 제공
- Spot 신호 감지
- 드레인 중 요청 수 추적
- 타임아웃/종료 대기

**Go의 동시성 모델:**
- goroutine: 가벼운 동시 작업
- channel: 안전한 신호 전달
- context: 타임아웃/취소 전파

복잡한 락 없이도 안정적인 제어 흐름을 구성할 수 있습니다.

### 4. 네트워크/I/O 중심 작업에 강함

**이 역할은 계산이 아니라:**
- HTTP 서버 (readiness/liveness)
- Cloud API 호출 (Cloud Monitoring)
- 메트릭 푸시
- 파일/소켓 감시 (메타데이터 서버)

**Go의 특징:**
- 표준 라이브러리만으로 충분 (`net/http`, `os/exec`, `encoding/json`)
- 성능 예측 가능
- 타임아웃/리트라이 패턴 구현이 간단

인프라 glue 코드에 최적화되어 있습니다.

### 5. 치명적 실패 영역에서의 신뢰성

**버그 발생 시 영향:**
- 요청이 중간에 끊김
- 서버가 준비되지 않은 상태에서 트래픽 수신
- Spot 회수에 대응 실패

**Go의 장점:**
- 컴파일 타임 에러 검출
- panic 영역이 명확
- nil/에러 처리 강제

조용히 실패하는 상황이 줄어듭니다.

### 6. 배포/운영 관점의 편의성

**에이전트 배포 방식:**
- 노드마다 설치 가능
- 사이드카로 실행 가능

**Go의 특징:**
- `scp` 하나로 배포 가능 (단일 바이너리)
- 컨테이너 크기 작음
- 스타트업 타임 빠름

운영팀 입장에서 다루기 쉬운 도구입니다.

### 7. 업계 표준 (Industry Standard)

**이 계층의 표준 언어가 Go:**
- Kubernetes core
- etcd
- Prometheus
- Envoy
- Docker

읽히고, 이해되고, 신뢰받기 쉬운 언어입니다.

---

## 최종 요약

**핵심 메시지:**

> Go는 "의미를 아는 작은 운영 컴포넌트"를 만들기 위해 가장 마찰이 적은 언어입니다.

**프로젝트 기준 역할 분담:**
- **Python**: LLM 추론 / 실험 / 모델 로직
- **Go**: 운영 에이전트 / 상태 관리 / 메트릭 / 신호 전달
- **Cloud**: 스케일 집행 / 복구 / 인프라

**결론:**

> Go는 빠르기 때문이 아니라, "오래 살아 있고 실수하면 안 되는 프로그램"에 적합하기 때문에 이 역할에 사용됩니다.
